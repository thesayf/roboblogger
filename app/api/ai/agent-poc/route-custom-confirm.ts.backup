// Simplified Agent POC - Inline Confirmation Pattern
// No complex session management, just simple tools with inline confirmation

import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { query, tool, createSdkMcpServer } from '@anthropic-ai/claude-agent-sdk';
import { z } from 'zod';
import dbConnect from '@/lib/mongo';
import Day from '@/models/Day';
import User from '@/models/User';
import {
  planCUDMultiAgent,
  planScheduleMultiAgent,
  planGoalMultiAgent,
  executeMultiAgent
} from '@/app/lib/ai/multi-agent-tools';
import Goal from '@/models/Goal';
import Project from '@/models/Project';
import Task from '@/models/Task';
import Routine from '@/models/Routine';
import Event from '@/models/Event';

// ==================== READ TOOLS (No Confirmation Needed) ====================

const readScheduleTool = tool(
  'readSchedule',
  'Read the user\'s schedule for a specific date',
  {
    date: z.string().optional().describe('Date in YYYY-MM-DD format. Defaults to today.')
  },
  async ({ date }) => {
    try {
      await dbConnect();
      const { userId } = auth();
      if (!userId) {
        return { content: [{ type: 'text' as const, text: 'Error: Not authenticated' }] };
      }

      const user = await User.findOne({ clerkId: userId }).lean();
      if (!user) {
        return { content: [{ type: 'text' as const, text: 'Error: User not found' }] };
      }

      let targetDate = date || new Date().toISOString().split('T')[0];

      const day = await Day.findOne({ user: user._id, date: targetDate })
        .populate({ path: 'blocks', populate: { path: 'tasks' } })
        .lean();

      if (!day || !day.blocks || day.blocks.length === 0) {
        return {
          content: [{
            type: 'text' as const,
            text: `No schedule found for ${targetDate}`
          }]
        };
      }

      const blocks = (day.blocks as any[]).map((b: any) => ({
        time: b.time,
        duration: b.duration,
        title: b.title,
        type: b.type,
        tasks: (b.tasks || []).map((t: any) => ({
          title: t.title,
          duration: t.duration,
          completed: t.completed
        }))
      }));

      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify({ date: targetDate, blocks })
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: 'text' as const,
          text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`
        }]
      };
    }
  }
);

const readInventoryTool = tool(
  'readInventory',
  'Read user\'s goals, projects, tasks, routines, or events',
  {
    type: z.enum(['all', 'goals', 'projects', 'tasks', 'routines', 'events']).optional()
      .describe('What to read. Defaults to all.')
  },
  async ({ type = 'all' }) => {
    try {
      await dbConnect();
      const { userId } = auth();
      if (!userId) {
        return { content: [{ type: 'text' as const, text: 'Error: Not authenticated' }] };
      }

      const inventory: any = {};

      if (type === 'all' || type === 'goals') {
        inventory.goals = await Goal.find({ userId }).sort({ order: 1 }).lean();
      }
      if (type === 'all' || type === 'projects') {
        inventory.projects = await Project.find({ userId, completed: false })
          .populate('tasks').sort({ order: 1 }).lean();
      }
      if (type === 'all' || type === 'tasks') {
        inventory.tasks = await Task.find({ userId, projectId: null, routineId: null, completed: false }).lean();
      }
      if (type === 'all' || type === 'routines') {
        inventory.routines = await Routine.find({ userId }).populate('tasks').lean();
      }
      if (type === 'all' || type === 'events') {
        inventory.events = await Event.find({ userId, date: { $gte: new Date() } })
          .sort({ date: 1, time: 1 }).limit(10).lean();
      }

      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify(inventory)
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: 'text' as const,
          text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`
        }]
      };
    }
  }
);

// ==================== DELETE TOOL (Inline Confirmation) ====================

const deleteTool = tool(
  'deleteItems',
  'Delete tasks, goals, projects, events, or routines. User has already confirmed deletion.',
  {
    reason: z.string().describe('Why you want to delete these items (e.g., "Delete all standalone tasks")')
  },
  async ({ reason }) => {
    try {
      const { userId } = auth();
      if (!userId) {
        return {
          content: [{
            type: 'text' as const,
            text: JSON.stringify({ success: false, error: 'Not authenticated' })
          }]
        };
      }

      console.log('ðŸ—‘ï¸ Executing deletion:', reason);

      // Generate plan and execute immediately (user already confirmed at HTTP level)
      const plan = await planCUDMultiAgent(userId, { reason });
      const result = await executeMultiAgent(userId, { plan });

      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify({
            success: true,
            executed: true,
            result: result,
            message: `âœ… Successfully deleted items`
          })
        }]
      };

    } catch (error) {
      console.error('ðŸ—‘ï¸ Error in deleteItems:', error);
      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify({
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          })
        }]
      };
    }
  }
);

// ==================== PLANNING TOOLS (Autonomous Execution) ====================

const planScheduleTool = tool(
  'planSchedule',
  'Plan a daily schedule. Executes immediately without confirmation.',
  {
    targetDate: z.string().describe('Date to plan (YYYY-MM-DD)'),
    planningStartTime: z.string().describe('When to start planning (HH:MM, e.g., "09:00")'),
  },
  async ({ targetDate, planningStartTime }) => {
    try {
      const { userId } = auth();
      if (!userId) {
        return {
          content: [{
            type: 'text' as const,
            text: JSON.stringify({ success: false, error: 'Not authenticated' })
          }]
        };
      }

      console.log('ðŸ“… Planning schedule for:', targetDate);

      // Generate the plan
      const plan = await planScheduleMultiAgent(userId, {
        targetDate,
        planningStartTime,
        mode: 'create'
      });

      // Execute immediately (no confirmation needed)
      const result = await executeMultiAgent(userId, { plan });

      const blockCount = result.result?.blocks?.length || 0;

      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify({
            success: true,
            executed: true,
            result: result,
            blockCount,
            message: `âœ… Created schedule for ${targetDate} with ${blockCount} blocks`
          })
        }]
      };

    } catch (error) {
      console.error('ðŸ“… Error in planSchedule:', error);
      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify({
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          })
        }]
      };
    }
  }
);

const planGoalTool = tool(
  'planGoal',
  'Create a goal with projects, tasks, and routines. Executes immediately without confirmation.',
  {
    goalDescription: z.string().describe('What the user wants to achieve'),
    timeline: z.string().optional().describe('How long (e.g., "3 months"). Defaults to appropriate timeframe.')
  },
  async ({ goalDescription, timeline }) => {
    try {
      const { userId } = auth();
      if (!userId) {
        return {
          content: [{
            type: 'text' as const,
            text: JSON.stringify({ success: false, error: 'Not authenticated' })
          }]
        };
      }

      console.log('ðŸŽ¯ Planning goal:', goalDescription);

      // Generate the plan
      const plan = await planGoalMultiAgent(userId, { goalDescription, timeline });

      // Execute immediately (no confirmation needed)
      const result = await executeMultiAgent(userId, { plan });

      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify({
            success: true,
            executed: true,
            result: result,
            message: `âœ… Created goal plan: ${goalDescription}`
          })
        }]
      };

    } catch (error) {
      console.error('ðŸŽ¯ Error in planGoal:', error);
      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify({
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          })
        }]
      };
    }
  }
);

// ==================== MCP SERVER ====================

const agentServer = createSdkMcpServer({
  name: 'agent-tools',
  version: '1.0.0',
  tools: [
    readScheduleTool,
    readInventoryTool,
    deleteTool,
    planScheduleTool,
    planGoalTool
  ]
});

// ==================== POST HANDLER ====================

export async function POST(req: NextRequest) {
  console.log("\nðŸ§ª AGENT POC (Simplified) - Request received");

  try {
    const { userId } = auth();
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    await dbConnect();

    const body = await req.json();
    let { message, deleteConfirmed } = body;

    // Check if message contains confirmation marker
    if (message && message.includes('|CONFIRMED')) {
      deleteConfirmed = true;
      message = message.replace('|CONFIRMED', '').trim();
    }

    console.log('ðŸ§ª User message:', message);
    console.log('ðŸ§ª Delete confirmed:', deleteConfirmed);

    // Detect if this is a deletion request
    const isDeletionRequest = /\b(delete|remove|clear)\b/i.test(message);

    if (isDeletionRequest && !deleteConfirmed) {
      console.log('ðŸ§ª Deletion detected - need confirmation first');

      // Use a simple query to preview what will be deleted
      const previewResult = query({
        prompt: `The user wants to: "${message}"\n\nWhat items would need to be deleted? List them clearly and ask for confirmation. Be specific about what will be deleted.`,
        options: {
          model: 'claude-sonnet-4-5-20250929',
          maxTurns: 5,
          mcpServers: {
            agentTools: agentServer
          },
          systemPrompt: `You are a helpful assistant. The user wants to delete something.

Your job:
1. Call readInventory to see what they have
2. Figure out what items match their delete request
3. List those items clearly
4. Ask: "Should I proceed with deleting these items?"

Do NOT actually delete anything yet - just preview and ask for confirmation.`
        }
      });

      let previewText = '';
      for await (const msg of previewResult) {
        if (msg.type === 'assistant' && msg.text) {
          previewText = msg.text;
        } else if (msg.type === 'result' && msg.text) {
          previewText = msg.text;
        }
      }

      // Ensure we have a message
      if (!previewText || previewText.trim() === '') {
        previewText = 'Ready to delete items. Should I proceed?';
      }

      return NextResponse.json({
        message: previewText,
        needsDeleteConfirmation: true
      });
    }

    // Create query with Claude Agent SDK
    console.log("ðŸ§ª Starting Claude Agent SDK query...");
    const result = query({
      prompt: message,
      options: {
        model: 'claude-sonnet-4-5-20250929',
        maxTurns: 50, // High limit to allow multi-step operations in one query
        mcpServers: {
          agentTools: agentServer
        },
        systemPrompt: `You are a helpful schedule planning assistant.

TOOLS AVAILABLE:
1. readSchedule - Read user's schedule for a date
2. readInventory - Read user's goals, projects, tasks, routines, events
3. deleteItems - Delete items (user has already confirmed if this tool is available)
4. planSchedule - Create a daily schedule (executes immediately)
5. planGoal - Create a goal plan (executes immediately)

CRITICAL RULES:

For DELETIONS:
- If deleteItems tool is available, the user has ALREADY confirmed deletion
- Just call deleteItems({ reason: "..." }) and execute
- Report success

For PLANNING (planSchedule, planGoal):
- Just call the tool - it executes immediately
- No confirmation needed (non-destructive operations)
- Report success

For MULTI-STEP OPERATIONS:
- Do deletions first, then planning
- Example: "Delete tasks and plan schedule"
  1. Call deleteItems (already confirmed by user)
  2. Call planSchedule
  3. Done!

IMPORTANT:
- Be conversational and helpful
- Explain what you're doing
- Summarize results clearly

EXAMPLE FLOWS:

User: "Show me my schedule"
You: [call readSchedule]
You: "Here's your schedule for today: ..."

User: "Delete all my tasks and plan tomorrow"
(User has already confirmed deletion at this point)
You: [call deleteItems]
You: [call planSchedule]
You: "Done! Deleted 3 tasks and created your schedule for tomorrow with 4 blocks."

User: "Plan a goal to learn Spanish in 3 months"
You: [call planGoal]
You: "Created your Spanish learning goal with 3 projects, 12 tasks, and 2 daily routines!"
`
      }
    });

    // Collect all messages from the agent
    console.log('ðŸ§ª Collecting messages from agent...');
    let finalResponse = '';
    let turnCount = 0;

    for await (const message of result) {
      turnCount++;
      console.log('ðŸ§ª Message type:', message.type);

      if (message.type === 'assistant') {
        console.log('ðŸ§ª Assistant message:', JSON.stringify(message, null, 2).substring(0, 500));
        if (message.text) {
          console.log('ðŸ§ª Assistant text:', message.text);
          finalResponse = message.text;
        }
      } else if (message.type === 'result') {
        console.log('ðŸ§ª Final result:', message.subtype);
        console.log('ðŸ§ª Result message:', JSON.stringify(message, null, 2).substring(0, 500));
        // Try different fields for the result text
        if (message.text) {
          finalResponse = message.text;
        } else if ((message as any).result) {
          finalResponse = (message as any).result;
        }
      }
    }

    console.log('ðŸ§ª Turns used:', turnCount);
    console.log('ðŸ§ª Final response:', finalResponse);

    return NextResponse.json({
      message: finalResponse || 'I apologize, but I encountered an issue processing your request.'
    });

  } catch (error) {
    console.error('ðŸ§ª Error in agent-poc:', error);
    return NextResponse.json(
      {
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
